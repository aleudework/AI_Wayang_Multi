## Operators Definition (for Apache Wayang plan generation)

All operators represent transformation steps in a Wayang plan.  
They are divided into three categories: **Input Operators**, **Unary Operators**, and **Binary Operators**.

Each operator must include the following base fields:
- **id** — Unique integer identifier for the operation (sequential number in the plan).  
- **input** — The `id` of the operator that provides its input data.  
- **output** — The `id` of the operator that receives its output data.  


Always remember to start the first operation (input operation) with id = 1 (not 0)

---

## 1. Input Operators

An input operator always have zero input but one to more outputs

### **jdbcRemoteInput**
- **Description:** Reads data from a database table using a JDBC connection.  
- **Use when:** You need to load data from a relational database into the Wayang pipeline.  
- **Fields:**  
  - `cat`: `"input"`  
  - `operatorName`: `"jdbcRemoteInput"`  
  - `table`: Name of the table to read from  
  - `columnNames`: List of columns to read  
  - `id`: Unique ID of this operator  
  - `output`: ID of the next operator or operators if more uses it for input

  ### **TextFileInput**
  - **Description:** Reads data line by line from a textfile
  - **Use when:** You need to load data from a textfile.
  - **Fields:**
    - `cat`: `"input"`  
    - `operatorName`: `"textFileInput"`  
    - `inputFileName`: Name of the input file. Only the filename. Don't include extentions or path
    - `id`: Unique ID of this operator  
    - `output`: ID of the next operator or operators if more uses it for input

---

## 2. Unary Operators

You can choose from the following **unary data transformation operations**.  
Each operator consumes a single input dataset and produces a single output dataset.
You can not have more than one output ids in unary operators.

---

### **Map**
- **Description:** Apply a function to each element (1 input → 1 output).  
- **Use when:** You need to transform data element-wise, e.g. compute new values or change structure.  
- **Fields:**
  - `cat`: `"unary"`  
  - `operatorName`: `"map"`  
  - `UDF`: Scala lambda function applied to each element  
  - `id`, `input`, `output`

---

### **FlatMap**
- **Description:** Apply a function that can return zero, one, or many elements (1 input → 0..n outputs).  
- **Use when:** Expanding or exploding data, e.g. splitting lists or strings.  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"flatMap"`  
  - `UDF`: Scala lambda function returning a list or sequence  
  - `id`, `input`, `output`

---

### **Filter**
- **Description:** Keep only elements that satisfy a Boolean condition.  
- **Use when:** Removing unwanted elements.  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"filter"`  
  - `UDF`: Scala lambda predicate function returning Boolean  
  - `id`, `input`, `output`

---

### **Reduce**
- **Description:** Combine all elements into one using a binary function `(A, A) => A`.  
- **Use when:** Producing a single aggregated result (e.g. sum, max).  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"reduce"`  
  - `UDF`: Scala binary reduction function  
  - `id`, `input`, `output`

---

### **ReduceBy**
- **Description:** Group elements by a key and reduce within each group.  
- **Use when:** You need grouped aggregation (e.g. sum by category).  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"reduceBy"`  
  - `KeyUDF`: Scala key extraction function  
  - `UDF`: Scala lambda reduction function per group  
  - `id`, `input`, `output`

---

### **GroupBy**
- **Description:** Group elements sharing the same key.  
- **Use when:** Clustering elements before further processing.  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"groupBy"`  
  - `KeyUDF`: Scala key extraction function  
  - `id`, `input`, `output`

---

### **Sort**
- **Description:** Order elements by a given key, ascending or descending.  
- **Use when:** Sorting data by key or value.  
- **Fields:**  
  - `cat`: `"unary"`  
  - `operatorName`: `"sort"`  
  - `keyUDF`: Scala key function used for ordering  
  - `id`, `input`, `output`

---

## 3. Binary Operators


You can choose from the following **binary data transformation operations**.  
Each operator consumes two input datasets and produces a single output dataset.

### **Join**
- **Description:** Joins to datasets together based on their keys.
- **Use when:** Joining to datasets together. It is an inner-join.
- **Fields:**  
  - `cat`: `"binary"`  
  - `operatorName`: `"join"`  
  - `thisKeyUDF`: Scala key extraction function  
  - `thatKeyUDF`: Scala key extraction function  
  - `id`, `input`, `output`


---


## 4. Output Operators

An output operator only have a sinlge input and zero output
Only use output operators if explicity asked for it. Otherwise the last operation in the plan is automatically the output and have an empty []

### **textFileOutput**
- **Description:** Return data in a textfile or .txt file
- **Use when:** You are asked to output the plan in a textfile or .txt file  
- **Fields:**  
  - `cat`: `"output"`  
  - `operatorName`: `"textFileOutput"`  
  - `id`: Unique ID of this operator  
  - `input`: ID of the operator which data should be outputted in a textfile
  

---


### General Notes
- Each operator must define a unique **id**.  
- The **input** and **output** fields establish the execution flow between operators.  
- **Binary operators** (e.g. `join`) have **two input references** (`inputLeft`, `inputRight`).  
- The final JSON output must conform to the **Wayang JSON schema** used by the `text_format` parser.  
- Keep `OperationName` values **exactly** as listed above.